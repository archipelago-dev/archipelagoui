{"version":3,"sources":["../core/vfs/memory-vfs.ts","../core/vfs/registry.ts","../core/runtime/utils.ts","../core/runtime/pubsub.ts","../core/runtime/lazy-import.ts","../core/runtime/render-worker-pool.ts","../core/runtime/hydration-controller.ts","../core/runtime/index.ts","../core/renderer/template-parser.ts","../main.ts","../core/vfs/adapter/disk-safe-vfs.ts","../core/crypto/hash.ts"],"sourcesContent":["import {\n    IVirtualFileSystem,\n    IVirtualFile,\n    FileMode,\n    FileInfo,\n    VfsFileHandle,\n} from \"./types\";\nimport path from \"path\";\n\n/* Internal representation */\ninterface InMemoryEntry {\n    data: Uint8Array;\n    info: FileInfo;\n}\n\nexport class MemoryVFS implements IVirtualFileSystem {\n    /* ------------------------------------------------------------------ */\n    /*  Interface props + constructor                                     */\n    /* ------------------------------------------------------------------ */\n    readonly scheme = \"mem\";\n\n    /* maps path → InMemoryEntry */\n    private files = new Map<string, InMemoryEntry>();\n    /* set of directory paths (always stored with a leading /) */\n    private directories = new Set<string>([\"/\"]);\n\n    constructor() {}\n\n    info(path: string): Promise<FileInfo> {\n        throw new Error(\"Method not implemented.\");\n    }\n    list(path: string): Promise<FileInfo[]> {\n        throw new Error(\"Method not implemented.\");\n    }\n\n    /* ------------------------------------------------------------------ */\n    /*  Lifecycle                                                         */\n    /* ------------------------------------------------------------------ */\n    async mount(): Promise<void> {\n        /* nothing to do for pure in‑mem, but keeps interface symmetrical  */\n    }\n\n    async unmount(): Promise<void> {\n        this.files.clear();\n        this.directories.clear();\n        this.directories.add(\"/\"); // keep root\n    }\n\n    /* ------------------------------------------------------------------ */\n    /*  File operations                                                   */\n    /* ------------------------------------------------------------------ */\n    async readFile(path: string): Promise<Uint8Array> {\n        const entry = this.files.get(path);\n        if (!entry) throw new Error(`File not found: ${path}`);\n        return entry.data;\n    }\n\n    async writeFile(path: string, data: Uint8Array): Promise<void> {\n        if (!(await this.exists(path))) {\n            await this.create(path);\n        }\n        const entry = this.files.get(path)!;\n        entry.data = data;\n        entry.info.size = data.length;\n        entry.info.updatedAt = Date.now();\n    }\n\n    async readdir(dir = \"/\"): Promise<VfsFileHandle[]> {\n        const handles: VfsFileHandle[] = [];\n\n        // Files directly under dir (non‑recursive)\n        for (const [filePath, entry] of this.files) {\n            if (filePath !== dir && filePath.startsWith(dir) && !filePath\n                .slice(dir.length)\n                .includes(\"/\")) {\n                handles.push({\n                    ...entry.info,\n                    mtime: 0\n                });\n            }\n        }\n\n        // Child directories\n        for (const sub of this.directories) {\n            if (sub !== dir && sub.startsWith(dir) && !sub.slice(dir.length).includes(\"/\")) {\n                handles.push({\n\n                    path: sub,\n                    size: 0,\n\n                    mtime: 0,\n                });\n            }\n        }\n\n        return handles;\n    }\n\n    async stat(path: string): Promise<VfsFileHandle | null> {\n        if (this.files.has(path)) return {mtime: 0, ...this.files.get(path)!.info };\n        if (this.directories.has(path)) {\n            return {\n                mtime: 0,\n\n                path,\n                size: 0,\n\n            };\n        }\n        return null;\n    }\n\n    /* ------------------------------------------------------------------ */\n    /*  Random‑access file API                                            */\n    /* ------------------------------------------------------------------ */\n    async open(path: string, mode: FileMode): Promise<IVirtualFile> {\n        if (!(await this.exists(path))) {\n            if (mode === FileMode.READ) {\n                throw new Error(`File not found: ${path}`);\n            }\n            await this.create(path);\n        }\n\n        const file = this.files.get(path)!;\n        let cursor = 0;\n\n        return {\n            async read(buffer: Uint8Array, length: number): Promise<number> {\n                const slice = file.data.slice(cursor, cursor + length);\n                buffer.set(slice, 0);\n                cursor += slice.length;\n                return slice.length;\n            },\n\n            async write(buffer: Uint8Array): Promise<number> {\n                // Expand buffer if we write past end\n                const newSize = Math.max(cursor + buffer.length, file.data.length);\n                const next = new Uint8Array(newSize);\n                next.set(file.data, 0);\n                next.set(buffer, cursor);\n                file.data = next;\n                file.info.size = next.length;\n                file.info.updatedAt = Date.now();\n                cursor += buffer.length;\n                return buffer.length;\n            },\n\n            async seek(offset: number, whence: \"SET\" | \"CUR\" | \"END\") {\n                if (whence === \"SET\") cursor = offset;\n                else if (whence === \"CUR\") cursor += offset;\n                else cursor = file.data.length + offset;\n            },\n\n            async flush() {/* no‑op for mem */},\n            async close() {/* no‑op for mem */},\n            async getInfo() { return { ...file.info }; },\n        };\n    }\n\n    /* ------------------------------------------------------------------ */\n    /*  Helpers                                                           */\n    /* ------------------------------------------------------------------ */\n    async create(path: string): Promise<void> {\n        const now = Date.now();\n        this.files.set(path, {\n            data: new Uint8Array(0),\n            info: {\n                name: path.split(\"/\").pop() || path,\n                path,\n                size: 0,\n                createdAt: now,\n                updatedAt: now,\n                isDirectory: false,\n            },\n        });\n    }\n\n    async delete(path: string): Promise<void> {\n        if (!this.files.delete(path)) {\n            throw new Error(`File not found: ${path}`);\n        }\n    }\n\n    async exists(path: string): Promise<boolean> {\n        return this.files.has(path) || this.directories.has(path);\n    }\n\n    async mkdir(path: string): Promise<void> {\n        this.directories.add(path.endsWith(\"/\") ? path.slice(0, -1) : path);\n    }\n\n    async rmdir(path: string, recursive = false): Promise<void> {\n        if (!this.directories.has(path)) throw new Error(`Directory not found: ${path}`);\n        this.directories.delete(path);\n        if (recursive) {\n            for (const filePath of [...this.files.keys()]) {\n                if (filePath.startsWith(`${path}/`)) this.files.delete(filePath);\n            }\n        }\n    }\n}\n\n/* Convenience factory */\nexport function createMemoryVFS(): IVirtualFileSystem {\n    const vfs = new MemoryVFS();\n    // optional: await vfs.mount(); (if you ever make mount asynchronous)\n    return vfs;\n}\n","// core/vfs/registry.ts\nimport type { IVirtualFileSystem } from \"./types\";\n\nclass Registry {\n    private adapters = new Map<string, IVirtualFileSystem>();\n\n    /** Register an adapter (e.g. new MemoryVFS() or DtlsVfsAdapter). */\n    register(adapter: IVirtualFileSystem): void {\n        if (this.adapters.has(adapter.scheme))\n            throw new Error(`VFS adapter for scheme \"${adapter.scheme}\" already registered`);\n        this.adapters.set(adapter.scheme, adapter);\n        // Eager‑mount by default (async fire‑and‑forget)\n        adapter.mount().catch(err => console.error(`[VFS] Mount error: ${err}`));\n    }\n\n    /** Fetch adapter by scheme (e.g. \"dtls\"). */\n    get(scheme: string): IVirtualFileSystem {\n        const a = this.adapters.get(scheme);\n        if (!a) throw new Error(`No VFS adapter registered for scheme \"${scheme}\"`);\n        return a;\n    }\n\n    /** Resolve a full path like \"dtls://host/file.txt\" into adapter + local path. */\n    private resolve(full: string): { adapter: IVirtualFileSystem; path: string } {\n        const [schemeRaw, rest] = full.split(\"://\");\n        const scheme = schemeRaw || \"mem\"; // default to memory VFS\n        return {\n            adapter: this.get(scheme),\n            // ensure exactly one leading slash on the local path\n            path: rest ? \"/\" + rest.replace(/^\\/+/, \"\") : \"/\",\n        };\n    }\n\n  async readFile(fullPath: string): Promise<Uint8Array> {\n    const { adapter, path } = this.resolve(fullPath);\n    return adapter.readFile(path);\n  }\n\n  async writeFile(fullPath: string, data: Uint8Array): Promise<void> {\n    const { adapter, path } = this.resolve(fullPath);\n    if (!adapter.writeFile) throw new Error(`${adapter.scheme} VFS is read‑only`);\n    await adapter.writeFile(path, data);\n  }\n\n  listSchemes(): string[] {\n    return Array.from(this.adapters.keys());\n  }\n}\n\n/** Export a singleton instance */\nexport const VfsRegistry = new Registry();\n","export function datasetToProps(el: HTMLElement): Record<string, any> {\n    const props: Record<string, any> = {};\n    for (const [key, value] of Object.entries(el.dataset)) {\n        try {\n            props[key] = JSON.parse(<string>value);\n        } catch {\n            props[key] = value;\n        }\n    }\n    return props;\n}\n\nexport function isVisible(el: Element): boolean {\n    const rect = el.getBoundingClientRect();\n    return rect.top < window.innerHeight && rect.bottom > 0;\n}\n","const subs: Record<string, Set<(data: any) => void>> = {};\n\nexport function publish(topic: string, data: any) {\n    subs[topic]?.forEach(fn => fn(data));\n}\n\nexport function subscribe(topic: string, fn: (data: any) => void): () => void {\n    if (!subs[topic]) subs[topic] = new Set();\n    subs[topic].add(fn);\n    return () => subs[topic].delete(fn);\n}\n","import { datasetToProps, isVisible } from \"./utils.js\";\nimport { subscribe } from \"./pubsub.js\";\n\nexport async function LazyImportElement(el: HTMLElement) {\n    const name = el.dataset.name;\n    if (!name) return;\n\n    const isRemote = name.startsWith(\"http://\") || name.startsWith(\"https://\");\n    const props = datasetToProps(el);\n    const container = document.createElement(\"div\");\n\n    el.replaceWith(container);\n\n    const hydrate = async () => {\n        try {\n            const mod = await import(/* @vite-ignore */ name)\n\n\n            const Component = mod?.default || mod;\n\n            if (typeof Component === \"function\") {\n                const output = Component(props);\n                if (output instanceof HTMLElement) {\n                    container.replaceChildren(output);\n                } else if (typeof output === \"string\") {\n                    container.innerHTML = output;\n                }\n            }\n        } catch (err) {\n            container.innerHTML = `<div style=\"color:red;\">Error loading \"${name}\"</div>`;\n            console.error(\"LazyImport error:\", err);\n        }\n    };\n\n    if (props.subscribe) {\n        subscribe(name, () => hydrate());\n    }\n\n}\n\nexport function hydrateVisibleLazyImports() {\n    const elements = document.querySelectorAll(\"lazy-import,LazyImport\");\n    elements.forEach(el => {\n        if (isVisible(el)) {\n            LazyImportElement(el as HTMLElement);\n        } else {\n            const io = new IntersectionObserver(([entry], obs) => {\n                if (entry.isIntersecting) {\n                    obs.unobserve(entry.target);\n                    LazyImportElement(entry.target as HTMLElement);\n                }\n            });\n            io.observe(el);\n        }\n    });\n}\n\n// Auto-run\nif (typeof window !== \"undefined\") {\n    if (document.readyState === \"loading\") {\n        document.addEventListener(\"DOMContentLoaded\", hydrateVisibleLazyImports);\n    } else {\n        hydrateVisibleLazyImports();\n    }\n}\n","import { HydrationDevOverlay } from '../devtools/hydration-dev-overlay';\n\n\ntype RenderJob = {\n    id: string;\n    template: string;\n    context: any;\n    options: any;\n    resolve: (html: string) => void;\n    reject: (err: any) => void;\n};\n\nexport class RenderWorkerPool {\n    private static instance: RenderWorkerPool;\n    private workers: Worker[] = [];\n    private queue: RenderJob[] = [];\n    private busy: Set<Worker> = new Set();\n\n    private constructor(private poolSize: number = navigator.hardwareConcurrency || 4) {\n        for (let i = 0; i < this.poolSize; i++) {\n            // @ts-ignore\n            const worker = new Worker(new URL('../workers/render.worker.ts', import.meta.url), {\n                type: 'module'\n            });\n\n            worker.onmessage = (e) => {\n                const { id, html, error } = e.data;\n                const job = this.queue.find(j => j.id === id);\n                if (!job) return;\n\n                if (error) job.reject(error);\n                else job.resolve(html);\n\n                this.busy.delete(worker);\n                HydrationDevOverlay.updateWorkerCount(this.busy.size);\n                this.dequeue();\n            };\n\n            this.workers.push(worker);\n        }\n    }\n\n    public static getInstance(): RenderWorkerPool {\n        if (!RenderWorkerPool.instance) {\n            RenderWorkerPool.instance = new RenderWorkerPool();\n        }\n        return RenderWorkerPool.instance;\n    }\n\n    public async render(template: string, context: any, options: any = {}): Promise<string> {\n        const id = `job-${Math.random().toString(36).substring(2, 8)}`;\n        return new Promise((resolve, reject) => {\n            this.queue.push({ id, template, context, options, resolve, reject });\n            this.dequeue();\n        });\n    }\n\n    private dequeue() {\n        if (this.queue.length === 0) return;\n\n        const idleWorker = this.workers.find(w => !this.busy.has(w));\n        if (!idleWorker) return;\n\n        const job = this.queue.shift();\n        if (!job) return;\n\n        this.busy.add(idleWorker);\n        HydrationDevOverlay.updateWorkerCount(this.busy.size);\n        idleWorker.postMessage({\n            id: job.id,\n            template: job.template,\n            context: job.context,\n            options: job.options,\n        });\n    }\n}\n","import { IController } from \"../types/controller.interface\";\nimport { RenderWorkerPool } from './render-worker-pool';\nimport {HydrationDevOverlay}  from \"../devtools/hydration-dev-overlay\";\n\nexport class HydrationController implements IController {\n    private static instance: HydrationController;\n\n    private hydrationMap: Map<string, boolean> = new Map();\n    private hydrationQueue: { el: HTMLElement; role: string; priority: number }[] = [];\n    private isProcessing = false;\n\n    private constructor() {}\n\n    public static getInstance(): HydrationController {\n        if (!HydrationController.instance) {\n            HydrationController.instance = new HydrationController();\n        }\n        return HydrationController.instance;\n    }\n\n    public async initialize(): Promise<void> {\n        console.log('HydrationController initialized');\n\n        if (typeof window !== 'undefined') {\n            const globalConfig = (window as any).ArchipelagoRenderer?.config;\n            if (globalConfig?.debug) {\n                const { HydrationDevOverlay } = await import('../devtools/hydration-dev-overlay');\n                HydrationDevOverlay.init();\n            }\n        }\n\n        this.setupIntersectionObserver();\n    }\n\n    public async destroy(): Promise<void> {\n        this.hydrationMap.clear();\n        this.hydrationQueue = [];\n        this.isProcessing = false;\n        console.log('HydrationController destroyed');\n    }\n\n    /**\n     * Public method to queue any hydratable component\n     */\n    public queueIslandHydration(el: HTMLElement, role: string): void {\n        const id = el.id || `island-${Math.random().toString(36).substring(2, 9)}`;\n\n        if (this.hydrationMap.has(id) || el.dataset.hydrated === 'true') return;\n\n        const priority = this.getPriority(el);\n        this.hydrationQueue.push({ el, role, priority });\n        this.hydrationQueue.sort((a, b) => a.priority - b.priority);\n\n        this.processQueue();\n    }\n\n    /**\n     * Hydration logic (de-duplicate, decorate, emit)\n     */\n    public async hydrateIsland(el: HTMLElement, role: string): Promise<void> {\n        const id = el.id || `island-${Math.random().toString(36).substring(2, 9)}`;\n        if (this.hydrationMap.has(id)) return;\n\n        this.hydrationMap.set(id, true);\n        el.dataset.hydrated = 'true';\n        el.classList.add('hydrated');\n\n        const template = el.outerHTML;\n        const context = {}; // Fill in actual data context\n        const options = { hydrate: true };\n\n        try {\n            const html = await RenderWorkerPool.getInstance().render(template, context, options);\n            el.outerHTML = html;\n\n            const event = new CustomEvent('archipelago:hydrated', {\n                bubbles: true,\n                detail: { id, role }\n            });\n            el.dispatchEvent(event);\n        } catch (err) {\n            console.error(`Failed to hydrate component ${id}:`, err);\n        }\n        HydrationDevOverlay.log(`Hydrated <${el.tagName.toLowerCase()}> (${role}) as ${id}`);\n        HydrationDevOverlay.updateQueueCount(this.hydrationQueue.length);\n    }\n\n    /**\n     * Hydrate 1 element per frame\n     */\n    private processQueue(): void {\n        if (this.isProcessing) return;\n        this.isProcessing = true;\n\n        const loop = () => {\n            const next = this.hydrationQueue.shift();\n            if (next) {\n                this.hydrateIsland(next.el, next.role);\n                requestAnimationFrame(loop);\n            } else {\n                this.isProcessing = false;\n            }\n        };\n\n        requestAnimationFrame(loop);\n    }\n\n    /**\n     * Convert priority string or number to normalized priority level\n     */\n    private getPriority(el: HTMLElement): number {\n        const raw = el.getAttribute('data-priority') || 'medium';\n        if (!isNaN(Number(raw))) return Number(raw);\n\n        return {\n            high: 1,\n            medium: 5,\n            low: 10,\n        }[raw] ?? 5;\n    }\n\n    /**\n     * IO observer for data-preload=\"onVisible\"\n     */\n    private setupIntersectionObserver(): void {\n        if (typeof window === 'undefined' || !('IntersectionObserver' in window)) return;\n\n        const observer = new IntersectionObserver((entries) => {\n            entries.forEach((entry) => {\n                if (entry.isIntersecting) {\n                    const el = entry.target as HTMLElement;\n                    const role = el.getAttribute('data-role') || 'component';\n                    const preload = el.getAttribute('data-preload');\n\n                    if (preload === 'onVisible') {\n                        this.queueIslandHydration(el, role);\n                    }\n\n                    observer.unobserve(entry.target);\n                }\n            });\n        }, {\n            rootMargin: '100px',\n            threshold: 0.1,\n        });\n\n        // Observe any matching element in DOM\n        document.querySelectorAll('[data-hydrate=\"true\"][data-preload=\"onVisible\"]').forEach(el => {\n            observer.observe(el);\n        });\n    }\n}\n","// @ts-ignore\nexport * from \"./lazy-import.js\";\n// @ts-ignore\nexport * from \"./hydration-controller.js\";\n// @ts-ignore\nexport * from \"./pubsub.js\";\n// @ts-ignore\nexport * from \"./utils.js\";\nif (typeof window !== \"undefined\") {\n    // @ts-ignore\n    window.__archipelago__ = {\n        version: \"0.1.0\",\n        name: \"Archipelago\",\n        description: \"A framework for building distributed applications.\"\n    };\n\n}","import { ParsedTemplate } from '../types';\n\nexport class TemplateParser {\n    constructor() {}\n\n    parse(template: string): ParsedTemplate {\n        const errors: string[] = [];\n        let componentName = '';\n        let attributes = {};\n        let slots = {};\n        let expressions: string[] = [];\n        let directives;\n\n        try {\n            componentName = this.extractComponentName(template) || '';\n            attributes = this.parseAttributes(template);\n            slots = this.parseSlots(template);\n            expressions = this.parseExpressions(template);\n            directives = this.parseDirectives(attributes);\n        } catch (err: any) {\n            errors.push(`Parsing failed: ${err.message}`);\n        }\n\n        return { componentName, attributes, slots, expressions, directives, errors };\n    }\n\n    private extractComponentName(template: string): string | null {\n        const match = template.match(/<([A-Z][a-zA-Z0-9]*)[\\s>]/);\n        return match ? match[1] : null;\n    }\n\n    private parseAttributes(template: string): Record<string, string> {\n        const attributes: Record<string, string> = {};\n        const attributeRegex = /([a-zA-Z0-9_:@\\-]+)=\"([^\"]*)\"/g;\n        let match;\n\n        while ((match = attributeRegex.exec(template)) !== null) {\n            const [, name, value] = match;\n            attributes[name] = value;\n        }\n\n        return attributes;\n    }\n\n    private parseSlots(template: string): Record<string, string> {\n        const slots: Record<string, string> = {};\n        const slotRegex = /<slot name=\"([^\"]*)\"[^>]*>([\\s\\S]*?)<\\/slot>/g;\n        let match;\n\n        while ((match = slotRegex.exec(template)) !== null) {\n            const [, name, content] = match;\n            slots[name] = content.trim();\n        }\n\n        return slots;\n    }\n\n    private parseExpressions(template: string): string[] {\n        const expressions: string[] = [];\n        const expressionRegex = /\\{\\{\\s*([^}]+?)\\s*\\}\\}/g;\n        let match;\n\n        while ((match = expressionRegex.exec(template)) !== null) {\n            const [, expr] = match;\n            expressions.push(expr.trim());\n        }\n\n        return expressions;\n    }\n\n    /**\n     * Extract directives like v-if, v-for, and :bindings from attributes\n     */\n    private parseDirectives(attributes: Record<string, string>): ParsedTemplate['directives'] {\n        const directives: ParsedTemplate['directives'] = {\n            bindings: {},\n        };\n\n        for (const [key, value] of Object.entries(attributes)) {\n            if (key === 'v-if') {\n                directives.vIf = value;\n            } else if (key === 'v-for') {\n                const match = value.match(/^([a-zA-Z0-9_$]+)\\s+in\\s+([a-zA-Z0-9_$.]+)$/);\n                if (match) {\n                    const [, item, iterable] = match;\n                    directives.vFor = { item, iterable };\n                }\n            } else if (key.startsWith(':')) {\n                const bindingName = key.slice(1);\n                directives.bindings![bindingName] = value;\n            }\n        }\n\n        return directives;\n    }\n}\n","/**\n * Archipelago “Hello over DTLS” demo\n *\n * 1. Registers an in‑memory VFS and the DTLS adapter.\n * 2. Reads JSON from `dtls://hello.json` (served by your echo server).\n * 3. Builds an <Island> template string with the message.\n * 4. Parses it via TemplateParser and hydrates it with HydrationController.\n */\n\nimport { createMemoryVFS }      from \"./core/vfs/memory-vfs\";\nimport { VfsRegistry }          from \"./core/vfs/registry\";\n\n\nimport { HydrationController }  from \"./core/runtime\";\nimport { TemplateParser }       from \"./core/renderer/template-parser\";\nimport * as path                     from \"path\";\nimport * as fs                       from \"fs\";\nimport {createDiskSafeVFS} from \"./core/vfs/adapter/disk-safe-vfs\";\n\n\n\nconst cert = fs.readFileSync(\n    // @ts-ignore\n    path.resolve(import.meta.dirname, \"./certs/client.crt\")\n);\nconst key  = fs.readFileSync(\n    // @ts-ignore\n    path.resolve(import.meta.dirname, \"./certs/client.key\")\n);\n// ────────────────────────────────────────────────────────────────\n// Bootstrap\n// ────────────────────────────────────────────────────────────────\n(async () => {\n    /* 1 ── Register default memory backend  */\n    VfsRegistry.register(createMemoryVFS());\n\n\n    VfsRegistry.register(\n      createDiskSafeVFS('./data') // scheme: disk-safe://\n\n    );\n    /* 2 ── Secure‑fetch JSON over DTLS */\n    const data    = await VfsRegistry.readFile(\"disk-safe://hello.json\");\n    const message = new TextDecoder().decode(data);\n\n    /* 3 ── Build Island markup */\n    const tplString = `<Island>Hello over DTLS: ${message}</Island>`;\n\n    /* 4 ── Parse via TemplateParser */\n    const parsed    = new TemplateParser().parse(tplString);\n\n    const h = HydrationController.getInstance();\n\n    /* 5 ── Hydrate into #root */\n    await h.hydrateIsland(\n        document.getElementById(\"root\")!,\n        parsed.toString()\n    );\n})();\n\n","// core/vfs/adapter/disk-safe-vfs.ts  — **Delta via bsdiff-node + Integrity**\n// -----------------------------------------------------------------------------\n// Requires in package.json:\n//   \"bsdiff-node\": \"^1.2.0\",\n//   \"@leancloud/blake3\": \"^0.5.0\"   (if not already for Blake3)\n// -----------------------------------------------------------------------------\n// Features:\n//   • Atomic writes, optional EncryptionScheme\n//   • Recursive listing, copy, rename, locks, chokidar watch\n//   • Per‑file versioning stored under .vfs_versions/<rel>\n//       – Uses *BSDIFF* (bsdiff-node) for binary deltas\n//       – Full snapshot stored if diff > 60 % size of plain\n//   • Metadata JSON includes BLAKE3 hash; hash verified on every read/restore\n//   • Automatic pruning by latest count, max versions, max age, max total bytes\n//   • Public helpers: listVersions / restoreVersion / purgeVersions\n// -----------------------------------------------------------------------------\n\n// @ts-nocheck\nfunction safeCwd(): string {\n    if (typeof process !== 'undefined' && typeof process.cwd === 'function') {\n        return process.cwd();\n    }\n    // in-browser, just mount at root\n    return '/';\n}\n\nimport {\n    IVirtualFileSystem, IVirtualFile, FileMode, FileInfo, VfsFileHandle\n} from '../types';\nimport { promises as fs } from 'node:fs';\nimport * as path from 'node:path';\nimport { randomBytes } from 'node:crypto';\nimport EventEmitter from 'node:events';\nimport chokidar from 'chokidar';\nimport { EncryptionScheme } from '../../interfaces/crypto';\nimport { Blake3 } from '../../crypto/hash';\nimport bsdiff from 'bsdiff-node';\n\n/* --------------------------------- Types ---------------------------------- */\ninterface DiskOpts {\n    root?: string;\n    crypto?: EncryptionScheme;\n    watch?: boolean;\n    versioning?: boolean;        // default true\n    prune?: {\n        keepLatest?: number;       // always retain N newest (default 5)\n        maxVersions?: number;      // per‑file cap\n        maxAgeDays?: number;       // delete versions older than X days\n        maxTotalBytes?: number;    // cap disk usage per file\n    };\n}\ninterface VersionMeta {\n    id: string;\n    hash: string;           // BLAKE3 of plain data\n    size: number;           // stored bytes\n    type: 'full' | 'delta';\n    parent?: string;\n    ctime: number;          // epoch ms\n}\n\n/* -------------------------------- Constants ------------------------------- */\nconst ROOT_DEFAULT = path.join(safeCwd(), 'data', 'vfs');\nconst VERS_DIR     = '.vfs_versions';\nconst META_EXT     = '.json';\nconst DELTA_EXT    = '.bsdiff';\n\n/* Path protect */\nconst safe = (root:string,p:string)=>{const r=path.resolve(root,p.replace(/^\\/+/,'')); if(!r.startsWith(root)) throw new Error('Path escape'); return r;};\n/* Cross‑platform sync */\nconst syncClose = async (h:fs.FileHandle)=>{ // @ts-ignore\n    if(typeof h.sync==='function') await h.sync(); await h.close(); };\n\n/* ---------------------------- DiskSafeVFS Class --------------------------- */\nexport class DiskSafeVFS extends EventEmitter implements IVirtualFileSystem {\n    prefix = '/';\n    scheme = 'disk-safe';\n    private readonly root: string;\n    private readonly crypto?: EncryptionScheme;\n    private watcher?: chokidar.FSWatcher;\n    private readonly versionsEnabled: boolean;\n    private readonly pruneCfg: Required<DiskOpts['prune']>;\n\n    constructor(private readonly opts: DiskOpts = {}) {\n        super();\n        this.root = path.resolve(opts.root ?? ROOT_DEFAULT);\n        this.crypto = opts.crypto;\n        this.versionsEnabled = opts.versioning !== false;\n        this.pruneCfg = {\n            keepLatest: 5,\n            maxVersions: 50,\n            maxAgeDays: 90,\n            maxTotalBytes: 50 * 1024 * 1024,\n            ...opts.prune\n        };\n    }\n\n    /* ---------------- Lifecycle ---------------- */\n    async mount() {\n        await fs.mkdir(this.root, { recursive: true });\n        if (this.versionsEnabled) {\n            await fs.mkdir(path.join(this.root, VERS_DIR), { recursive: true });\n        }\n        if (this.opts.watch) {\n            this.watcher = chokidar.watch(this.root, { ignoreInitial: true, depth: Infinity });\n            ['add', 'change', 'unlink', 'addDir', 'unlinkDir']\n                .forEach(evt => this.watcher!.on(evt, p => this.emit(evt, path.relative(this.root, p))));\n        }\n    }\n    async unmount() { await this.watcher?.close(); }\n\n    /* ---------------- Encryption helpers ---------------- */\n    private async enc(data: Uint8Array) { return this.crypto ? this.crypto.encrypt(data) : data; }\n    private async dec(data: Uint8Array) { return this.crypto ? this.crypto.decrypt(data) : data; }\n\n    /* ---------------- Atomic write ---------------- */\n    private async atomicWrite(full: string, data: Uint8Array) {\n        const dir = path.dirname(full);\n        await fs.mkdir(dir, { recursive: true });\n        const tmp = path.join(dir, `.tmp-${randomBytes(4).toString('hex')}`);\n        const fh = await fs.open(tmp, 'wx', 0o600);\n        await fh.writeFile(data);\n        await syncClose(fh);\n        await fs.rename(tmp, full);\n    }\n\n    /* ---------------- Version helpers ---------------- */\n    private versDir(rel: string) { return path.join(this.root, VERS_DIR, path.dirname(rel)); }\n\n    private async latestMeta(rel: string): Promise<VersionMeta | null> {\n        const metas = await this.listMetas(rel);\n        return metas[0] ?? null;\n    }\n\n    private async listMetas(rel: string): Promise<VersionMeta[]> {\n        const dir = this.versDir(rel);\n        try {\n            const files = (await fs.readdir(dir)).filter(f => f.startsWith(path.basename(rel)) && f.endsWith(META_EXT));\n            const metas: VersionMeta[] = await Promise.all(files.map(async f => JSON.parse((await fs.readFile(path.join(dir, f))).toString())));\n            return metas.sort((a, b) => b.ctime - a.ctime);\n        } catch { return []; }\n    }\n\n    private async loadVersionData(rel: string, id: string): Promise<Uint8Array> {\n        const dir  = this.versDir(rel);\n        const base = path.join(dir, `${path.basename(rel)}.${id}`);\n        const meta: VersionMeta = JSON.parse((await fs.readFile(base + META_EXT)).toString());\n        const stored = await this.dec(await fs.readFile(base + (meta.type === 'delta' ? DELTA_EXT : '.full')));\n        let plain: Uint8Array;\n        if (meta.type === 'full') {\n            plain = stored;\n        } else {\n            const parent = await this.loadVersionData(rel, meta.parent!);\n            plain = bsdiff.patch(parent, stored);\n        }\n        // integrity check\n        if (Blake3.from(plain).hex !== meta.hash) throw new Error('Version hash mismatch – data corrupted');\n        return plain;\n    }\n\n    private async saveVersion(rel: string, plain: Uint8Array) {\n        if (!this.versionsEnabled) return;\n        const dir = this.versDir(rel);\n        await fs.mkdir(dir, { recursive: true });\n\n        const ts = new Date().toISOString().replace(/[:.]/g, '-');\n        const id = ts;\n        const metaName = `${path.basename(rel)}.${id}${META_EXT}`;\n        const metaPath = path.join(dir, metaName);\n\n        let type: 'full' | 'delta' = 'full';\n        let payload: Uint8Array;\n        let parentId: string | undefined;\n\n        const prev = await this.latestMeta(rel);\n        if (prev) {\n            const prevPlain = await this.loadVersionData(rel, prev.id);\n            const diffBuf = bsdiff.diff(prevPlain, plain);\n            if (diffBuf.length < plain.length * 0.6) {\n                type = 'delta';\n                payload = diffBuf;\n                parentId = prev.id;\n            } else {\n                payload = plain;\n            }\n        } else {\n            payload = plain;\n        }\n\n        const encrypted = await this.enc(payload);\n        const dataPath = metaPath.replace(META_EXT, type === 'delta' ? DELTA_EXT : '.full');\n        await this.atomicWrite(dataPath, encrypted);\n\n        const meta: VersionMeta = {\n            id,\n            hash: Blake3.from(plain).hex,\n            size: encrypted.length,\n            type,\n            parent: parentId,\n            ctime: Date.now()\n        };\n        await this.atomicWrite(metaPath, Buffer.from(JSON.stringify(meta)));\n        await this.pruneVersions(rel);\n    }\n\n    /* ---------------- Pruning ---------------- */\n    private async pruneVersions(rel: string) {\n        const metas = await this.listMetas(rel);\n        const { keepLatest, maxVersions, maxAgeDays, maxTotalBytes } = this.pruneCfg;\n\n        // keepLatest first\n        let candidates = metas.slice(keepLatest);\n\n        // enforce maxVersions\n        if (metas.length > maxVersions) candidates = metas.slice(maxVersions);\n\n        // age filter\n        const cutoff = Date.now() - maxAgeDays * 86_400_000;\n        candidates.push(...metas.filter(m => m.ctime < cutoff));\n\n        // size filter\n        let keptSize = metas.filter(m => !candidates.includes(m)).reduce((s, m) => s + m.size, 0);\n        for (const m of metas) {\n            if (candidates.includes(m)) continue;\n            if (keptSize <= maxTotalBytes) break;\n            candidates.push(m);\n            keptSize -= m.size;\n        }\n\n        // dedup and delete\n        const toDel = [...new Set(candidates)];\n        for (const m of toDel) {\n            const base = path.join(this.versDir(rel), `${path.basename(rel)}.${m.id}`);\n            await fs.rm(base + META_EXT, { force: true });\n            await fs.rm(base + (m.type === 'delta' ? DELTA_EXT : '.full'), { force: true });\n        }\n    }\n\n    /* ---------------- IVirtualFileSystem: open ---------------- */\n    async open(rel: string, mode: FileMode): Promise<IVirtualFile> {\n        const full = safe(this.root, rel);\n\n        if (mode === FileMode.READ) {\n            const raw   = await fs.readFile(full);\n            const plain = await this.dec(raw);\n            let cursor = 0;\n            return {\n                async read(buf, len) {\n                    const slice = plain.slice(cursor, cursor + len);\n                    buf.set(slice);\n                    cursor += slice.length;\n                    return slice.length;\n                },\n                write: async () => { throw new Error('read-only handle'); },\n                seek: async (off, whence) => {\n                    cursor = whence === 'SET' ? off : whence === 'CUR' ? cursor + off : plain.length + off;\n                },\n                flush: async () => {},\n                close: async () => {},\n                getInfo: async () => this.info(rel)\n            } as IVirtualFile;\n        }\n\n        const chunks: Uint8Array[] = [];\n        return {\n            async read() { throw new Error('write-only handle'); },\n            async write(chunk) { chunks.push(chunk); return chunk.length; },\n            async seek() {},\n            async flush() {},\n            close: async () => {\n                const plain = Uint8Array.from(Buffer.concat(chunks));\n                await this.saveVersion(rel, plain);\n                await this.atomicWrite(full, await this.enc(plain));\n            },\n            getInfo: async () => this.info(rel)\n        } as IVirtualFile;\n    }\n\n    /* ---------------- Convenience & Metadata ---------------- */\n    async exists(p: string) {\n        try { await fs.access(safe(this.root, p)); return true; } catch { return false; }\n    }\n\n    async info(p: string): Promise<FileInfo> {\n        const st = await fs.stat(safe(this.root, p));\n        return { path: p, size: st.size, mtime: st.mtimeMs, isDir: st.isDirectory() } as FileInfo;\n    }\n\n    async readFile(p: string) { return this.dec(await fs.readFile(safe(this.root, p))); }\n\n    async writeFile(p: string, data: Uint8Array) {\n        await this.saveVersion(p, data);\n        await this.atomicWrite(safe(this.root, p), await this.enc(data));\n    }\n\n    async delete(p: string) {\n        if (await this.exists(p)) {\n            const current = await this.readFile(p);\n            await this.saveVersion(p, current);\n            await fs.rm(safe(this.root, p), { force: true });\n        }\n    }\n\n    async mkdir(p: string) { await fs.mkdir(safe(this.root, p), { recursive: true }); }\n\n    async rmdir(p: string, recursive = false) {\n        await fs.rm(safe(this.root, p), { recursive, force: true });\n    }\n\n    async list(rel: string = '/') {\n        const out: FileInfo[] = [];\n        const recurse = async (dirRel: string) => {\n            const abs = safe(this.root, dirRel);\n            for (const ent of await fs.readdir(abs, { withFileTypes: true })) {\n                const childRel = path.join(dirRel, ent.name);\n                out.push(await this.info(childRel));\n                if (ent.isDirectory()) await recurse(childRel);\n            }\n        };\n        await recurse(rel);\n        return out;\n    }\n\n    async readdir(rel: string = '/') {\n        return (await this.list(rel)).filter(f => path.dirname(f.path) === rel);\n    }\n\n    async stat(p: string) { return (await this.exists(p)) ? await this.info(p) : null; }\n\n    async copy(src: string, dst: string) {\n        await fs.cp(safe(this.root, src), safe(this.root, dst), { recursive: true });\n    }\n\n    async rename(src: string, dst: string) {\n        await fs.rename(safe(this.root, src), safe(this.root, dst));\n    }\n\n    /* ---------------- Version public helpers ---------------- */\n    async listVersions(p: string) { return this.listMetas(p); }\n    async restoreVersion(p: string, id: string) {\n        const data = await this.loadVersionData(p, id);\n        await this.atomicWrite(safe(this.root, p), await this.enc(data));\n    }\n    // @ts-ignore\n    async purgeVersions(p: string, keepLatest = this.pruneCfg.keepLatest) {\n        const metas = await this.listMetas(p);\n        for (const m of metas.slice(keepLatest)) {\n            const base = path.join(this.versDir(p), `${path.basename(p)}.${m.id}`);\n            await fs.rm(base + META_EXT, { force: true });\n            await fs.rm(base + (m.type === 'delta' ? DELTA_EXT : '.full'), { force: true });\n        }\n    }\n\n    async create(p: string) {\n        const full = safe(this.root, p);\n        await fs.mkdir(path.dirname(full), { recursive: true });\n        await fs.writeFile(full, Buffer.alloc(0));\n    }\n}\n\nlet fs: typeof import('fs/promises');\nlet randomBytes: typeof import('crypto').randomBytes;\n\nconst isNode = typeof process !== 'undefined' && process.versions?.node;\n\nif (isNode) {\n    const fsModule = await import('node:fs/promises');\n    const cryptoModule = await import('node:crypto');\n    fs = fsModule;\n    randomBytes = cryptoModule.randomBytes;\n}\n\nexport async function createDiskSafeVFS(rootDir: string) {\n    if (!isNode) {\n        throw new Error('Disk-safe VFS is only available in Node.js environments');\n    }\n\n    return {\n        async readFile(filePath: string) {\n            const absPath = path.resolve(rootDir, filePath);\n            return fs.readFile(absPath);\n        },\n\n        async writeFile(filePath: string, data: Uint8Array) {\n            const absPath = path.resolve(rootDir, filePath);\n            return fs.writeFile(absPath, data);\n        },\n\n        async randomSeed(length = 32): Promise<Uint8Array> {\n            return randomBytes(length);\n        }\n    };\n}","import { blake3 } from '@noble/hashes/blake3';\n\nexport interface HashResult {\n  readonly hash: Uint8Array;\n  readonly mac?: Uint8Array;\n  readonly key?: Uint8Array;\n  readonly ctx?: Uint8Array;\n  readonly hex: string;\n  readonly base64: string;\n}\n\nexport class Blake3 implements HashResult {\n  readonly hash: Uint8Array;\n  readonly mac?: Uint8Array;\n  readonly key?: Uint8Array;\n  readonly ctx?: Uint8Array;\n  readonly hex: string;\n  readonly base64: string;\n\n  constructor(input: string, context?: string, key?: Uint8Array) {\n    const inputBytes = new TextEncoder().encode(input);\n    this.hash = blake3(inputBytes);\n\n    this.hex = Buffer.from(this.hash).toString('hex');\n    this.base64 = Buffer.from(this.hash).toString('base64');\n\n    if (key) {\n      this.key = blake3(this.hash, { key });\n    }\n\n    if (context) {\n      this.ctx = blake3(this.hash, { context });\n    }\n\n    this.mac = blake3(this.hash, { key: new Uint8Array(32) }); // default MAC\n  }\n\n  /**\n   * Creates a new Blake3 instance and returns only the result\n   */\n  static from(input: string, context?: string, key?: Uint8Array): HashResult {\n    return new Blake3(input, context, key);\n  }\n\n  /**\n   * Convert the result to a JSON-safe object\n   */\n  toJSON(): Record<string, string> {\n    return {\n      hex: this.hex,\n      base64: this.base64,\n      mac: this.mac ? Buffer.from(this.mac).toString('hex') : '',\n      key: this.key ? Buffer.from(this.key).toString('hex') : '',\n      ctx: this.ctx ? Buffer.from(this.ctx).toString('hex') : ''\n    };\n  }\n}\n"],"mappings":"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","names":["path","path","key","resolve","HydrationDevOverlay","key","path","fs"]}