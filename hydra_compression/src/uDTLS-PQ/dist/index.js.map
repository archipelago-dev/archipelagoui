{"version":3,"sources":["../src/udtls-pq.ts","../src/lib/types.ts","../src/index.ts"],"sourcesContent":["import { EventEmitter } from \"node:events\";\nimport dgram            from \"node:dgram\";\nimport { createRequire } from \"node:module\";\n//  * Generate a Falcon key pair for post-quantum secure signatures\n\n\n// ── Types ─────────────────────────────────────────────────────────────────────\nimport {\n    DTLSContext,\nDTLSSession,\n    DTLSContextOptions,\n    DTLSVersion,\n    PQCipherSuite,\n    VerifyMode,\n} from \"./lib/types\";\n\n/* -------------------------------------------------------------------------- */\n/*  Public enums & interfaces                                                 */\n/* -------------------------------------------------------------------------- */\n\nexport enum SecurityLevel {\n    STANDARD = \"standard\",\n    POST_QUANTUM_MEDIUM = \"pq-medium\",\n    POST_QUANTUM_HIGH = \"pq-high\",\n    HYBRID = \"hybrid\",\n}\n\nexport interface DTLSOptions {\n    isServer?: boolean;\n    cert?: string | Buffer;\n    key?: string | Buffer;\n    securityLevel?: SecurityLevel;\n    minVersion?: \"1.0\" | \"1.2\" | \"1.3\";\n    maxVersion?: \"1.2\" | \"1.3\";\n    cipherSuites?: string[];\n    verifyPeer?: boolean;\n    debug?: boolean;\n    timeout?: number;\n    mtu?: number;\n    autoFallback?: boolean;\n}\n\nexport enum ConnectionState {\n    CLOSED        = \"closed\",\n    HANDSHAKE     = \"handshake\",\n    CONNECTING    = \"connecting\",\n    CONNECTED     = \"connected\",\n    DISCONNECTED  = \"disconnected\",\n    ERROR         = \"error\",\n}\n\nexport class DTLS extends EventEmitter {\n    private context!: DTLSContext;\n    private session!: DTLSSession;\n\n    private readonly opts: {\n        isServer: boolean;\n        securityLevel: SecurityLevel;\n        minVersion: string | \"1.0\" | \"1.2\" | \"1.3\";\n        maxVersion: string | \"1.2\" | \"1.3\";\n        verifyPeer: boolean;\n        debug: boolean;\n        timeout: number;\n        mtu: number;\n        autoFallback: boolean;\n        cipherSuites: any[] | string[];\n        cert?: string | Buffer;\n        key?: string | Buffer\n    };\n    private state: ConnectionState = ConnectionState.CLOSED;\n    private socket?: dgram.Socket;\n\n    constructor(options: DTLSOptions) {\n        super();\n\n        /* default‑merge */\n        this.opts = {\n            isServer: false,\n            securityLevel: SecurityLevel.STANDARD,\n            minVersion: \"1.2\",\n            maxVersion: \"1.3\",\n            verifyPeer: true,\n            debug: false,\n            timeout: 30_000,\n            mtu: 1400,\n            autoFallback: true,\n            cipherSuites: [],\n            ...options,\n        };\n\n        /* Validate & init context */\n        this.initContext();\n    }\n\n    /* ------------------------------------------------------------------ */\n    /*  Context / Session Helpers                                         */\n    /* ------------------------------------------------------------------ */\n\n    private initContext(): void {\n        if (!this.opts.cert || !this.opts.key)\n            throw new Error(\"Certificate & key required for DTLS context\");\n\n        if (this.compareVer(this.opts.minVersion, this.opts.maxVersion) > 0)\n            throw new Error(\"minVersion cannot exceed maxVersion\");\n\n        const ctxOpts: DTLSContextOptions = {\n            cert: typeof this.opts.cert === \"string\"\n                ? Buffer.from(this.opts.cert)\n                : this.opts.cert,\n            key:  this.opts.key as Buffer,\n            ciphers: this.opts.cipherSuites,\n            pqCiphers: this.pickPqSuites(),\n            enableCertTransparency: true,\n            minVersion: this.mapVersion(this.opts.minVersion),\n            maxVersion: this.mapVersion(this.opts.maxVersion),\n            verifyMode: this.opts.verifyPeer ? VerifyMode.PEER : VerifyMode.NONE,\n            isServer: this.opts.isServer,\n        };\n// @ts-ignore\n        this.context = nativeBindings.createContext(ctxOpts);\n        if (!this.context) throw new Error(\"DTLS context init failed\");\n    }\n\n    private pickPqSuites(): PQCipherSuite[] | undefined {\n        switch (this.opts.securityLevel) {\n            case SecurityLevel.POST_QUANTUM_MEDIUM:\n                return [PQCipherSuite.KYBER512_AES_128_GCM_SHA256];\n            case SecurityLevel.POST_QUANTUM_HIGH:\n                return [PQCipherSuite.KYBER768_AES_256_GCM_SHA384];\n            case SecurityLevel.HYBRID:\n                return [\n                    PQCipherSuite.KYBER512_AES_128_GCM_SHA256,\n                    PQCipherSuite.KYBER768_AES_256_GCM_SHA384,\n                ];\n            default:\n                return undefined;\n        }\n    }\n\n    private mapVersion(v: string | \"1.0\" | \"1.2\" | \"1.3\"): DTLSVersion | undefined {\n        return {\n            \"1.0\": DTLSVersion.DTLS_1_0,\n            \"1.2\": DTLSVersion.DTLS_1_2,\n            \"1.3\": DTLSVersion.DTLS_1_3,\n        }[v];\n    }\n\n    private compareVer(a: string, b: string) {\n        return parseFloat(a) - parseFloat(b);\n    }\n\n    /* ------------------------------------------------------------------ */\n    /*  Client Connect                                                    */\n    /* ------------------------------------------------------------------ */\n    connect(port: number, host: string, cb?: () => void) {\n        if (this.state !== ConnectionState.CLOSED)\n            throw new Error(\"DTLS instance already used\");\n\n        if (this.opts.isServer) throw new Error(\"Server mode cannot connect()\");\n        this.socket = dgram.createSocket(\"udp4\");\n\n\n        this.session = new DTLSSession(this.context.id);\n        // @ts-ignore\n        nativeBindings.setupAutomaticRekey(this.session.id, 3600);\n        // @ts-ignore\n        const ok = nativeBindings.dtlsConnect(this.session, host, port);\n        if (!ok) {\n          //  @ts-ignore\n            const err = nativeBindings.getError(this.session) ?? \"DTLS connect error\";\n            return this.handleError(new Error(err));\n        }\n\n        this.state = ConnectionState.HANDSHAKE;\n        this.setupSocketEvents();\n        if (cb) this.once(\"connect\", cb);\n    }\n\n    /* ------------------------------------------------------------------ */\n    /*  UDP Socket Event Wiring                                           */\n    /* ------------------------------------------------------------------ */\n    private setupSocketEvents() {\n        const sock = this.socket!;\n        sock.on(\"message\", (msg) => this.onUdpData(msg));\n        sock.on(\"error\", (e) => this.handleError(e));\n        sock.on(\"close\", () => {\n            this.state = ConnectionState.DISCONNECTED;\n            this.emit(\"close\");\n        });\n    }\n\n    private onUdpData(msg: Buffer) {\n        if (!msg?.length) {\n            this.emit(\"error\", new Error(\"Empty UDP packet\"));\n            return;\n        }\n\n        try {\n            //@ts-ignore\n            const res = nativeBindings.dtlsReceive(this.session, msg);\n            if (res.handshakeComplete && this.state !== ConnectionState.CONNECTED) {\n                this.state = ConnectionState.CONNECTED;\n                this.emit(\"connect\");\n            }\n            if (res.data) this.emit(\"message\", res.data as Buffer);\n        } catch (e) {\n            this.handleError(e as Error);\n        }\n    }\n\n    /* ------------------------------------------------------------------ */\n    /*  Send / Close                                                      */\n    /* ------------------------------------------------------------------ */\n\n    send(data: Buffer | string) {\n        if (this.state !== ConnectionState.CONNECTED)\n            throw new Error(\"DTLS not connected\");\n\n        const buf   = typeof data === \"string\" ? Buffer.from(data) : data;\n        //@ts-ignore\n        const cipher= nativeBindings.aesGcmSeal(buf, buf, buf, buf); // demo only\n        //@ts-ignore\n        this.socket!.send(cipher, 0, cipher.length, this.socket!.remotePort!, this.socket!.remoteAddress!);\n    }\n\n    close() {\n        //@ts-ignore\n        try { nativeBindings.dtlsShutdown(this.session); } catch { /* ignore */ }\n        //@ts-ignore\n        nativeBindings.freeSession?.(this.session);\n        //@ts-ignore\n        nativeBindings.freeContext?.(this.context);\n        this.socket?.close();\n        this.state = ConnectionState.CLOSED;\n    }\n\n    /* ------------------------------------------------------------------ */\n    /*  Error utility                                                     */\n    /* ------------------------------------------------------------------ */\n    private handleError(err: Error) {\n        this.state = ConnectionState.ERROR;\n        this.emit(\"error\", err);\n        this.close();\n    }\n}\n","// src/lib/types.ts\nimport { EventEmitter } from 'events';\n\nexport enum DTLSVersion {\n    DTLS_1_0 = 'DTLS 1.0',\n    DTLS_1_2 = 'DTLS 1.2',\n    DTLS_1_3 = 'DTLS 1.3',\n}\n\nexport enum VerifyMode {\n    NONE = 0,\n    PEER = 1,\n    FAIL_IF_NO_PEER_CERT = 2,\n    CLIENT_ONCE = 4,\n}\n\nexport enum ConnectionState {\n    HANDSHAKE = 'handshake',\n    CONNECTED = 'connected',\n    CLOSING = 'closing',\n    CLOSED = 'closed',\n    ERROR = 'error'\n}\n\nexport interface DTLSSocketOptions {\n    address: string;\n    port: number;\n    cert?: string | Buffer;\n    key?: string | Buffer;\n    ca?: string | Buffer | Array<string | Buffer>;\n    ciphers?: string[];\n    pqCiphers?: string[];\n    minVersion?: DTLSVersion;\n    maxVersion?: DTLSVersion;\n    verifyMode?: VerifyMode;\n    requestCert?: boolean;\n    rejectUnauthorized?: boolean;\n    timeout?: number;\n    retransmits?: number;\n    mtu?: number;\n}\n\nexport interface EnhancedDTLSOptions extends DTLSSocketOptions {\n    autoRekey?: boolean;\n    rekeyInterval?: number;\n    rekeyDataLimit?: number;\n    earlyData?: boolean;\n    earlyDataSize?: number;\n}\n\nexport class DTLSSocket extends EventEmitter {\n    constructor(options: DTLSSocketOptions) {\n        super();\n    }\n\n    connect(options?: any): Promise<void> {\n        return Promise.resolve();\n    }\n\n    send(data: Buffer): Promise<void> {\n        return Promise.resolve();\n    }\n\n    close(): Promise<void> {\n        return Promise.resolve();\n    }\n\n    sendClientHello(clientHello: any): Promise<any> {\n        return Promise.resolve({});\n    }\n\n    hasValidSessionTicket(): boolean {\n        return false;\n    }\n\n    useBufferPool(param: { initialSize: number; packetSizes: number[] }) {\n        \n    }\n\n    enableCryptoPrecomputation(param: { dhParamsCache: boolean; staticKeyCache: boolean }) {\n        \n    }\n\n    enablePacketBatching(param: {maxDelay: number; maxSize: number}) {\n        \n    }\n}\n\nexport enum PQAlgorithm {\n    KYBER512 = 'kyber512',\n    KYBER768 = 'kyber768',\n    KYBER1024 = 'kyber1024',\n    DILITHIUM2 = 'dilithium2',\n    DILITHIUM3 = 'dilithium3',\n    DILITHIUM5 = 'dilithium5',\n}\n\n/** Opaque handle coming back from native `createContext(...)` */\nexport class DTLSContext { constructor(public id: number) {} }\n/** Opaque handle coming back from native `createSession(...)` */\nexport class DTLSSession { constructor(public id: number) {} }\n\nexport enum PQCipherSuite {\n    KYBER512_AES_128_GCM_SHA256 = 'TLS_KYBER512_WITH_AES_128_GCM_SHA256',\n    KYBER768_AES_256_GCM_SHA384 = 'TLS_KYBER768_WITH_AES_256_GCM_SHA384',\n    KYBER1024_AES_256_GCM_SHA512 = 'TLS_KYBER1024_WITH_AES_256_GCM_SHA512',\n}\n\n/**\n * Schedule an automatic rekey on a DTLS session.\n * @param sessionId   the numeric handle for your session\n * @param intervalMs  how often to rekey, in milliseconds\n */\n\n\ndeclare function setupAutomaticRekey<T>(sessionId: number, intervalMs: number): void;\n\nexport interface DTLSContextOptions {\n    cert?: string | Buffer;\n    key?: string | Buffer;\n    ca?: string | Buffer | Array<string | Buffer>;\n    crl?: string | Buffer | Array<string | Buffer>;\n    ciphers?: string[];\n    pqCiphers?: PQCipherSuite[];\n    minVersion?: DTLSVersion;\n    maxVersion?: DTLSVersion;\n    verifyMode?: VerifyMode;\n    requestCert?: boolean;\n    rejectUnauthorized?: boolean;\n    enableCertTransparency?: boolean;\n    pskIdentityHint?: string;\n    pskKey?: Buffer;\n    isServer: boolean;\n}\n\nexport interface DTLSConnectionOptions {\n    socket: any; // dgram.Socket\n    context: DTLSContext;\n    peerAddress: string;\n    peerPort: number;\n    mtu?: number;\n    timeout?: number;\n    retransmits?: number;\n}\n\n\n\nexport type PQKeyPair = {\n    publicKey: any;\n    privateKey: any;\n};\n\n/**\n * Types and interfaces for hybrid PQ certificates and DTLS-PQ.\n */\n\n/** Classical asymmetric key types */\nexport enum ClassicalKeyType {\n    ECDSA_P256 = 'ECDSA_P256',\n    RSA_2048 = 'RSA_2048'\n}\n\n\n\n/** Distinguished Name for certificate subject or issuer */\nexport interface SubjectDN {\n    commonName: string;\n    organization?: string;\n    organizationalUnit?: string;\n    country?: string;\n    state?: string;\n    locality?: string;\n}\n\n/** Certificate generation options */\nexport interface CertificateOptions {\n    keyType: ClassicalKeyType;\n    pqAlgorithm: PQAlgorithm;\n    subject: SubjectDN;\n    issuerCert?: Buffer;\n    issuerKey?: Buffer;\n    validityDays: number;\n    isCA?: boolean;\n    keyUsage?: string[];\n    extendedKeyUsage?: string[];\n    altNames?: string[];\n    policies?: string[];\n    pqPublicKeyOID: string;\n    classicalPublicKeyOID: string;\n    crlDistributionPoints?: string[];\n    ocspURLs?: string[];\n}\n\n/** Public and private key pair */\nexport interface HybridKeyPair {\n    publicKey: Buffer;\n    privateKey: Buffer;\n}\n\n/** X.509 extension structure */\nexport interface X509Extension {\n    oid: string;\n    critical: boolean;\n    value: Buffer;\n}\n","'use strict';\n\n\nimport { DTLS, SecurityLevel } from './udtls-pq';\n\nconst dtls = new DTLS({\n    isServer: false, securityLevel: SecurityLevel.HYBRID, cert: Buffer.from('mock-cert'), key: Buffer.from('mock-key')});\nexport { dtls };"],"mappings":"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","names":[]}